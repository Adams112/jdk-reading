# Java常用锁
![java主流锁](https://github.com/Adams112/jdk-reading/blob/master/images/20190616200439354_.png 'java主流锁')

整理给自己看的，讲不清楚，记下重点。  
## volatile
volatile并不是锁，在这里一并写上。  
volatile是java语言提供的一种同步方法。volatile可以保证**有序性**，即禁止JVM对指令进行重排序，可以保证**可见性**，即一个线程可以看到另一个线程对变量做的修改，但不能保证**原子性**。  
  
**volatile如何保证可见性**----缓存一致性协议MESI  
缓存一致性协议给缓存行（通常为64字节）定义了个状态：独占（exclusive）、共享（share）、修改（modified）、失效（invalid），用来描述该缓存行是否被多处理器共享、是否修改。所以缓存一致性协议也称MESI协议。

独占（exclusive）：仅当前处理器拥有该缓存行，并且没有修改过，是最新的值。  
共享（share）：有多个处理器拥有该缓存行，每个处理器都没有修改过缓存，是最新的值。  
修改（modified）：仅当前处理器拥有该缓存行，并且缓存行被修改过了，一定时间内会写回主存，会写成功状态会变为S。  
失效（invalid）：缓存行被其他处理器修改过，该值不是最新的值，需要读取主存上最新的值。  

一个处于M状态的缓存行，必须时刻监听所有试图读取该缓存行对应的主存地址的操作，如果监听到，则必须在此操作执行前把其缓存行中的数据写回CPU。  
一个处于S状态的缓存行，必须时刻监听使该缓存行无效或者独享该缓存行的请求，如果监听到，则必须把其缓存行状态设置为I。  
一个处于E状态的缓存行，必须时刻监听其他试图读取该缓存行对应的主存地址的操作，如果监听到，则必须把其缓存行状态设置为S。  
当CPU需要读取数据时，如果其缓存行的状态是I的，则需要从内存中读取，并把自己状态变成S，如果不是I，则可以直接读取缓存中的值，但在此之前，必须要等待其他CPU的监听结果，如其他CPU也有该数据的缓存且状态是M，则需要等待其把缓存更新到内存之后，再读取。  
当CPU需要写数据时，只有在其缓存行是M或者E的时候才能执行，否则需要发出特殊的RFO指令(Read Or Ownership，这是一种总线事务)，通知其他CPU置缓存无效(I)，这种情况下会性能开销是相对较大的。在写入完成后，修改其缓存状态为M。  

**volatile如何保证有序性**----内存屏障  
内存屏障分为4种：
LoadLoad屏障：（指令Load1; LoadLoad; Load2），在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。  
LoadStore屏障：（指令Load1; LoadStore; Store2），在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。  
StoreStore屏障：（指令Store1; StoreStore; Store2），在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。  
StoreLoad屏障：（指令Store1; StoreLoad; Load2），在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能  

这一篇比较详细(https://www.jianshu.com/p/6745203ae1fe)

## synchronized
**细节没看明白**  
锁升级：无锁-偏向锁-轻量级锁-重量级锁  
锁优化：适应性自旋锁，锁粗化，锁消除    

同步代码块，锁住括号中的对象  
同步方法，锁住调用对象
静态同步方法，锁住.class对象  

**底层是如何加锁和释放锁的？**--对象头：锁标志，是否可偏向，（线程id--偏向锁，栈中锁指针--轻量级锁，互斥量指针--重量级锁）  
1. 锁标志01(无锁或偏向锁)  
好像没有地方讲cas操作，比较的值是什么？我的理解是比较的永远是无锁状态的markword，也就是每个线程都是从无锁状态得到锁的。  
如果是无锁状态。cas替换线程id，替换成功获得锁  
如果是偏向锁状态。如果线程id与自身id相等，直接获得锁。如果不相等，查看原线程状态，如果原线程已经退出或者不拥有该锁，则将该对象置为无锁状态，可以重新偏向其他线程。如果继续持有该锁，则锁升级为轻量级锁。  
偏向锁不会主动释放锁。  

2. 锁标志00（轻量级锁）  
通过cas获取锁，不成功则自旋。不成功超过一定次数则锁会升级。  
释放，cas释放锁。  

3. 锁标志10(重量级锁)  
如果别的线程拥有锁，直接挂起，等待唤醒

**锁是如何升级的**  
1. 偏向锁-轻量级锁  
当一个线程持有锁，另一个线程还需要锁时，锁会升级  

2. 轻量级锁-重量级锁
自选超过一定次数。


![synchronized加锁过程](https://github.com/Adams112/jdk-reading/blob/master/images/20180908110545722.png 'synchronized加锁过程')


## ReentrantLock

## synchronized和ReentrantLock比较

## synchronized深度理解

## ReentrantReadWriteLock

## CAS
